<br/>

>[!WARNING|style: flat|label:  简要说明 ]
>
>- 描述配置树中的 [ 某个配置节点 ]，其提供的(`API`)在逻辑上体现出 <span style='color:Blue'>[ 树形层次结构 - 称为：逻辑配置树 ]</span>
>
>```csharp
>public interface IConfiguration
>{
>
>       string this[string path] { get; set; }            
>       IConfigurationSection GetSection(string path);     // [ 逻辑获取 ]当前节点下子节点
>       IEnumerable<IConfigurationSection> GetChildren();  // [ 逻辑获取 ]当前路径下子节点路径( 排除重复 - Key )
>
>       # [ 回调通知 ] 监控数据源的变化 
>       IChangeToken GetReloadToken();
> 
> }
> 
> 
> ```
> 
> 
> 
><br/>

<!-- tabs:start -->

#### **[ 根节点 ]IConfigurationRoot**

```csharp
# [ 描述 - 逻辑树 ] 整棵配置树
public interface IConfigurationRoot : IConfiguration
{
    
      IEnumerable<IConfigurationProvider> Providers { get; }
      # [ 显示重载 ] 刷新配置树
      void Reload(); 
      
}


```

```csharp
public class ConfigurationRoot : IConfigurationRoot, IDisposable
{

       private readonly IList<IConfigurationProvider> _providers;
       public IEnumerable<IConfigurationProvider> Providers 
           => this._providers;
      
       private readonly IList<IDisposable> _changeTokenRegistrations;
       public ConfigurationRoot(IList<IConfigurationProvider> providers)
       {

             this._providers = providers;
             this._changeTokenRegistrations = new List<IDisposable>(providers.Count);

             foreach (IConfigurationProvider p in this._providers)
             {
                   
                   # [ 数据转换 ] 中间字典
                   p.Load();
                   # [ 监控通知 ] 数据源的变化 → 回调通知
                   IDisposable _disposable = ChangeToken.OnChange(p.GetReloadToken, this.RaiseChanged);
                   this._changeTokenRegistrations.Add(_disposable);

             }

       }
    
       #region [ 回调通知 ] 监控数据源的变化 
          
       private ConfigurationReloadToken _changeToken = new ConfigurationReloadToken();  
       public IChangeToken GetReloadToken() => this._changeToken;
      
       private void RaiseChanged()
       {
            
            # [ 重置状态 ] 
            ConfigurationReloadToken previousToken = Interlocked.Exchange(ref this._changeToken, new ConfigurationReloadToken());
            previousToken.OnReload();
            
       }
     
       #endregion
           
       public string this[string path]
       {
             get => {
               
                  # [ 倒序: 后来者居上 ] 相同路径 Key -> 后面的 IConfigurationProvider 具有更高的优先级
                  for (int i = this.providers.Count - 1; i >= 0; i--)
                  {
                       if (providers[i].TryGet(path, out string value))
                           return value;
                  }
                  return null;
                  
             };
             set => {
                  
                  // [ 内存 ]
                  foreach (IConfigurationProvider provider in providers)
                      this.provider.Set(path, value);
             };
       }
       
       # [ 重要：逻辑获取 ] 当前节点下子节点( 创建路径节点：ConfigurationSection )
       public IConfigurationSection GetSection(string path) => new ConfigurationSection(this, path);
       public IEnumerable<IConfigurationSection> GetChildren();

       public void Reload()
       {
             foreach (IConfigurationProvider provider in _providers)
                 provider.Load();
             this.RaiseChanged();
       }
    
       public void Dispose()
       {

             foreach (IDisposable registration in this._changeTokenRegistrations)
                 registration.Dispose();

             foreach (IConfigurationProvider provider in this._providers)
                 (provider as IDisposable)?.Dispose();

       }

}


```



#### **[ 非根节点 ]IConfigurationSection**

!> <span style='color:red'>注意事项：路径分隔符使用`:`</span>

```csharp
# [ 配置子节点 ]
public interface IConfigurationSection : IConfiguration
{
    
      string Key { get; }   // [ 节点标识 ] 路径 A:B:C => C
      string Path { get; }  // [ 逻辑 ] 节点全路径
      
      string Value { get; set; } 
    
}


```

```csharp
public class ConfigurationSection : IConfigurationSection
{

       # [ 同根引用 ]
       private readonly IConfigurationRoot _root;
       
       public string Key => ConfigurationPath.GetSectionKey(this._path);
       private readonly string _path;
       public string Path => this._path;
    
       public ConfigurationSection(IConfigurationRoot root, string path)
       {
            this._root = root;
            this._path = path;
       }
    
       public string Value
       {
            get => this._root[this.Path];
            set => this._root[this.Path] = value;
       }
    
       public string this[string path]
       {
            get => this._root[this.Path + ":" + path];
            set => this._root[this.Path + ":" + path] = value;
       }

       # [ 逻辑路径 ] this.Path + path
       /// <summary>
       /// - 中间字典: ["A:A01:A0101"] = "Test";
       ///   IConfigurationRoot.GetSection("A:A01") - <Key: "A01", Path: "A:A01", Value: Null>
       ///                     .GetSection("A0101") - <Key: "A0101", Path: "A:A01:A0101", Value: Test>
       /// </summary>
       public IConfigurationSection GetSection(string path) => this._root.GetSection(this, path: (this.Path + ":" + path) );
       public IEnumerable<IConfigurationSection> GetChildren();
    
       public IChangeToken GetReloadToken() => this._root.GetReloadToken();

}


```





<!-- tabs:end -->

```csharp
var source = new Dictionary<string, string>
{
      ["A:B:C"] = "ABC"
};
IConfigurationRoot root = new ConfigurationBuilder()
                             .AddInMemoryCollection(source)
                             .Build();


IConfigurationSection section1 = root.GetSection("A");       //Key: A, Path : A, Value: NULL
IConfigurationSection section2 = section1.GetSection("B:C"); //Key: C, Path : A:B:C, Value: ABC


```













