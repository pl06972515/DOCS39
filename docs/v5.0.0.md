<br/>

>[!WARNING|style: flat|label:  中间字典 ]
>
>- 配置数据通过`IConfigurationProvider`对象转换成 <span style='color:Blue'>[ 中间字典`IDictionary<string, string>`]</span> 
>
>  <span style='color:red'>[ 注意事项：此接口中的方法大部分体现对字典的操作`Key: 描述路径`，其分隔符固定为`:`]</span>
>
>
>```csharp
>public interface IConfigurationProvider
>{
>
>       void Set(string key, string value);
>       bool TryGet(string key, out string value);
>    
>       # [ 加载 ] 配置字典
>       void Load();
>
>       # [ 监听 ] 数据变更
>       IChangeToken GetReloadToken();
>       IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string parentPath);
>
>}
>
>
>```
>
><br/>

```csharp
# [ 内置 ] 默认实现
public abstract class ConfigurationProvider : IConfigurationProvider
{

      # [ 中间字典 ] 配置数据
      protected IDictionary<string, string> Data { get; set; }
      protected ConfigurationProvider() => this.Data = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

      public virtual void Set(string key, string value) => this.Data[key] = value;
      public virtual bool TryGet(string key, out string value) => this.Data.TryGetValue(key, out value);

      public virtual void Load() { }

      #region [ 监控 ] 数据源变更

      private ConfigurationReloadToken _reloadToken = new ConfigurationReloadToken();
      public IChangeToken GetReloadToken() => this._reloadToken;

      protected void OnReload()
      {
           # [ 重置 ] 数据状态
           ConfigurationReloadToken previousToken = Interlocked.Exchange(ref _reloadToken, new ConfigurationReloadToken());
           previousToken.OnReload();
      }

      #endregion

      /*... 代码忽略 ...*/   

}


```

